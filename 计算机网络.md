## 1.osi模型
    7层， 物理层， 数据链路层， 网络层， 传输层， 会话层， 表示层， 应用层
    ** 物理层 **
    物理层的设备 中继器 集线器


    ** 数据链路层 **
    数据链路层分为逻辑链路控制字层LLC， 媒体访问控制子层MAC
    数据链路层负责分配MAC地址， MAC地址又叫物理地址， 48比特长， 12个十六进制数字组成， 前6位16进制（0-23位）是厂商向IETF等机构申请用来标志厂商的代码， 后6位16进制有厂商自行分派， 是各个厂商制造的所有网卡的一个唯一编号， 因此一个网卡有一个全球唯一固定的MAC地址， 但是可以对应多个IP地址
    设备 网桥， 交换机

    **网络层**
    负责对数据包进行路由选择和存储转发
    提供点到点的通信， 只是提供一台机器到另一台机器的通信， 不会涉及到进程
    网络层协议有 IP IPX ICMP IGMP ARP RARP OSPF
    网络层的数据单位称为分组或者数据包
    网路层中继系统： 路由器

    **传输层**
    是一个端到端， 即进程到进程的层
    由于一个主机可以同时运行多个进程， 因此传输层有复用和分用的功能
    传输层的协议有 TCP UDP SCTP
    传输层的数据单位叫报文或者数据段
    中继系统：网关

    **应用层**
    为操作系统或者网络应用程序提供访问网络服务的接口
    应用层的协议有 RIP TELNET FTP HTTP SNMP
    中继系统： 网关
    
## 2. TCP/IP模型
    网络接口层 网际层 传输层 应用层

    ** 网络接口层 **
    = 物理层 + 数据链路层

    ** 网际层 **
    是关键部分， 网际层 = osi的网络层， 将分组转发到任何网络， 并为之独立的选择路由， 但是不保证各个分组有序到达
    各个分组的交付有高层负责
    网际层定义了标准的分组格式和协议 IP协议

    ** 传输层 **
    传输层的功能 = osi传输层
    使发送端到目的端主机上的对等实体可以进行会话
    传输层的两种协议
    TCP： 传输控制协议 面向连接 数据传输的单位是报文段， 可以提供可靠的交付
    UDP： 用户数据报协议, 无连接的， 数据传输的单位是用户数据报， 不保证但是尽最大努力提供交付

    ** 应用层 **
    包含所有的高层协议
    虚拟终端协议 TELNET； 文本传输协议 FTP； 域名解析服务DNS； 电子邮件协议SMTP； 超文本传输协议HTTP

# 传输层和socket基本操作
## 2.1 传输层
    UDP ：用户数据报协议 无连接， 客户与服务器不必存在长期的关系， 例如一个UDP客户创建一个套接字发送给一个数据给服务器，
    然后立即用同一个套接字发送给另一个数据报给另一个服务器。 同样， 一个UDP服务器可以用同一个UDP套接字从若干不同的客户
    一连串的接受多个数据报
    UDP是不可靠的 不能保证送达 不能保证顺序 也不能保证每个数据报只到达一次
    UDP既可以用ipv4 也可以用ipv6

    TCP：传输控制协议 面向连接 可靠
    1.当发送数据时需要确认， 如果没有确认会自动重传数据并等待更长时间， 在数次重传失败以后会放弃
    2.通过给发送的每一个字节关联一个序列号进行排序
    3.提供流量控制， 总是告诉对端他能接受多少字节的数据， 叫通告窗口， 该窗口在任何时刻都支出接受缓存区中的可用空间， 从而确保发送端发送的数据不4.会溢出接受缓存区
    5.连接是双全工的， 即数据在两个方向都可以同时传递
## tcp连接的建立与终止
    先从服务端说起
    服务端调用socket函数， 返回一个套接字 ， 套接字与地址、端口绑定bind， 对端口进行监听listen， 调用accept阻塞， 等待客户端连接
    这时候如果有客户端调用了socket函数返回一个套接字， 然后连接服务器connect， 如果连接成功这是客户端与服务端的连接就建立了
    客户端发送数据请求， 服务器端接受请求并处理请求， 然后把相应数据发送给客户端， 客户端读取数据， 最后关闭连接一次交互就结束

    名词的意义
    SYN 同步序号， 表示该报文是一个连接请求或者连接接受报文
    ACK 确认位     对接受带的报文的确认
    FIN 终止位     表示发送方完成数据发送， 用来释放一个连接
    RST 复位连接   表示TCP连接中出现严重错误
    PSH 推送位     尽可能快的吧数据送往接受进程

    **三次握手**
    1. 客户端向服务器端发送SYN J
    2. 服务器端向客户端响应一个 SYN K， 并对SYN J进行确认ACK J+1
    3. 客户端再次向服务器发送一个确认ACK K+1
    服务器必须准备好接受外来的连接， 这通过socket， bind， listen函数完成
    客户端通过调用connect主动打开， 引起客户端向服务器端发送SYN J ， 客户端的connect进入阻塞状态
    服务器端监听到连接请求， 调用accept函数接受请求， 并向客户端发送SYN K， ACK J+1 ， accept进入阻塞状态
    客户端接受到SYN K， ACK J+1, 这时connect返回， 并对SYN K进行确认
    服务器端收到ACK K+1分节时， accept返回， 至此三次握手完毕， 连接建立

    注意 客户端的connect在三次握手的第二次返回， 服务器端的accept在三次握手的第三次返回

    **四次挥手**
    终止一个连接需要四次挥手， 这是由于TCP的半关闭造成的half-close
    TCP连接是双全工的，就是两个方向可以同时进行通信， 因此每个方向必须单独的进行关闭
    1. 某个应用进程手垫调用close， 我们称这一端执行主动关闭， 这段的TCP于是发送一个FIN分节， 表示数据发送完毕
    2. 另一端接收到FIN分节之后执行被动关闭， 并对FIN分节进行确认， 他的接受也作为文件结束符传递给接收端的应用进程， 因为FIN的接受意味着应用进程在相应的连接上再也收不到额外数据
    3. 一段时间以后接收到文件结束符的应用调用close关闭他的套接口，这将导致他的TCP也发送一个FIN
    4. 接收到这个FIN的原发送端TCP（就是执行主动关闭的那一端）对它进行确认

## TCP状态转换图
    TCP为一个状态定义了11中状态， 并且规定了如何基于当前状态及在该状态下所接收的分节从一个状态转换到另一个状态
    举例来说， 当某个应用进程在CLOSED状态下执行主动打开时， TCP将发送一个SYN， 且新的状态是SYN_SENT
    如果这个TCP接受到一个带ACK的SYN， 它将发送一个ACK， 并且新的状态是ESTABLISHED， 这个最终状态是绝大多数数据传送发生的状态
    找那个图吧画的比较详细

    二次握手为什么不行
    三次握手是为了防止失效的连接请求报文段突然又传到服务器，从而发生错误
    当客户段发出的连接请求报文段由于某些原因没有及时到达服务器， 而客户端在等待一段时间后有重新向服务器端请求且建立成功顺序完成数据传输， 那么第一次发送的请求就是失效的连接请求报文段。
    考虑这样的问题， 如果客户端第一次发送的连接请求并没有丢失而胡思因为网络问题导致延迟到达服务器， 而服务器以为是客户端又发起的新的连接于是同意并返回确认， 但是这个时候客户端不会理会， 服务器端就一直等， 导致资源浪费

    为何四次挥手
    关闭连接收到对方的FIN请求时仅仅代表对方没有数据发送给你了， 但是未必你所有的数据群斗发送给对方了， 所以你未必会马上关闭socket， 也就是说你还需要发送一些数据给人对方后再发送FIN告诉对方你灭有数据发送了， 然后针对每个FIN都需要一个ACK报文， 所以需要4挥手

## socket基本操作
    介绍一个完整的TCP客户和服务器程序所需要的基本套接字接口函数

    **socket函数**
    int socket(int domain, int type, int protocol);
    socket函数在成功时返回一个小的非负整数值， 称为套接口描述字 socket descriptor 简称套接字
    参数：domain 协议域， 决定了套接口的地址类型
          type 指定套接口类型 
          protocol 指定协议
    
    ** bind **
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    把一个本地协议地址赋予套接口
    通常服务器在启动的时候都会绑定一个众所周知的地址用于提供服务
    而客户端不用指定， 有系统自动分配

    **listen**
    int listen(socket s, int backlog)
    listen函数有TCP服务器调用， 
    1. 调用listen导致套接口从close状态变成listen状态
    2. 规定了应该为该套接口排队的最大连接个数（包括已完成连接队列和未完成连接队列）

    ** connect()**
    int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)

    ** accept**
    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
    如果accept成功会返回一个有内核自动生成的全新的描述子代表TCP连接

    **close**
    关闭套接口
    int close(int fd)
    close只是使相应套接字引用计数减1， 只有到0的时候才会去触发TCP发送终止连接请求

    一个面向连接的客户端socket程序的主要步骤
    1. 加载套接字库
    2. 创建套接字（socket()）
    3. 向服务器发送连接请求connect
    4. 和服务器进行通信
    5. 关闭套接字

    **shutdown**
    关闭socket的两种方法： close shutdown
    int shutdown(int sockfd, int howto)
    SHUT_RD 关闭读端， 也就是该套接字不再接受数据
    SHUT_WR 不让写 仍可读 套接字socket半关闭状态

    ** TCP的半关闭 **
    TCP提供了连接的一端在结束他的发送后还能接受来自另一端数据逇能力


# 网络层
## ipv4地址及网络地址转换NAT
1. IPv4地址
    连接在internet的每台主机都分配一个32bit的全球唯一的标志服， 也就是ip地址
    ip地址的编码方法有三种： 分类的ip地址，子网的划分， CIDR
    传统的IP地址是分类的地址， 分为ABCDE五类 都由网络号和主机好两部分组成 网络号代表连接到的网络， 主机号代表主机或路由器在网络中的地址
    0.0.0.0 表示整个TCPIP网络
    127.0.0.1表示主机本身
    255.255.255.255 表示整个TCPIP网络的广播地址
2. NAT
    网络地址转换是指通过将专用网络地址转换为公网地址，从而对外隐藏了内部管理的IP地址，从而减少了IP注册费用和越来越少的IPV4地址空间
    部分私有地址： 10.0.0.0 - 10.255.255.255  172.16.0.0 - 172.31.255.255 192.168.0.0 - 192.168.255.255
    私有ip地址不能直接用于internet， 必须通过网关利用NAT吧私有IP地址转换为internet中合法的全球ip地址
3. 子网划分， 子网掩码， CIDR
    回去自己看吧这里讲的不细
4. ARP RARP ICMP
    手机网络的数据链路中传送数据的时候最终必须使用硬件地址， 所以需要一种方法来完成IP到MAC地址的映射， 这就要用到地址解析协议ARP
    每台主机路由器上单独存放一个从IP地址到MAC地址的映射表，成为ARP表， 主机和路由器使用地址解析协议ARP来动态维护这张表
    ARP ： 物理地址转IP地址
    RARP： 相反
    ping命令使用的是ICMP协议网络层的， ping没有用到传输层的tcp或udp协议
5. ipv6
    有128bit构成， 通常每个16bit的值用四位十六进制表示， 每个值之间用冒号分割
    特点：
    1. 更大的地址空间
    2. 扩展的地址层次结构
    3. 灵活的首部格式
    4. 改进的选项
    5. 允许协议继续扩充
    6. 支持即插即用
    7. 支持资源的预分配
    8. 增加了安全性，身份验证和保密验证是ipv6的关键特征

    ** HTTP状态码 **
    1XX：消息， 表示请求已经接受 需要继续处理
    2XX：成功 
    3XX：重定向
    4XX：客户端错误 400表示语义有错误导致服务器端不能理解
    5XX：服务器端错误

    ** 输入网址后发生了**
    1. 浏览器向DNS服务器查询URL对应的IP地址
    2. DNS返回IP地址
    3. 浏览器打开TCP连接 默认端口是80 并向web服务器发送HTTP请求
    4. 若页面发生跳转吗服务器则以一个重定向响应， 然后转到5， 否则到6
    5. 浏览器跟随重定向， 再次发送HTTP请求
    6. 服务器处理请求， 并发回HTML响应
    7. 浏览器接受请求的页面源码
    8. 浏览器开始渲染HTML
    9. 浏览器发送嵌入到HTML中的对象请求
    10.浏览器进一步发送异步请求ajax
    11.浏览器关闭TCP连接

# 网路测试常用工具
    ** ping **
    检查网络是否通畅， 或者网络连接速度的命令
    利用网络上机器IP地址的唯一性， 给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据报来确定两台网络机器是否能够相通， 时延是多少

    ** tracert **
    是路由跟踪实用程序， 用于确定IP数据包访问目标所采取的路径
    该命令使用IP生存时间TTL字段和ICMP错误消息来确定从一个主机到网络上其他主机的路由
    可以用该命令确定数据包在网络上的停止位置
    
    ** telnet **
    在网络测试中非常实用， 可以用telnet测试80端口的web服务器是否正常工作

    ** netstat **
    监控TCPIP网络的非常有用的工具， 可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息